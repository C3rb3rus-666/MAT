#!/usr/bin/env python
# -*- coding: utf-8 -*

'''
    Metadata anonymisation toolkit - GUI edition
'''

from gi.repository import GObject, Gtk
from gi.repository import Gdk, GdkPixbuf

import gettext
import logging
import os
import sys
import mimetypes
import xml.sax
import urllib2

from MAT import mat
from MAT import strippers

logging.basicConfig(level=mat.LOGGING_LEVEL)


class CFile(GObject.Object):
    '''
        Contain the "parser" class of the file "filename"
        This class exist just to be "around" my parser.Generic_parser class,
        since the Gtk.ListStore does not accept it because it does not
        extends Gobject.Object
    '''
    def __init__(self, filename, backup, **kwargs):
        self.file = mat.create_class_file(filename, backup, **kwargs)


class GUI(object):
    '''
        Main GUI class
    '''
    def __init__(self):
        # Preferences
        self.force = False
        self.backup = True
        self.add2archive = True
        self.pdf_quality = False

        # Main window
        self.builder = Gtk.Builder()
        self.builder.add_from_file(os.path.join(mat.get_datadir(), 'mat.ui'))
        self.builder.connect_signals(self)

        self.logo = mat.get_logo()
        icon = GdkPixbuf.Pixbuf.new_from_file_at_size(self.logo, 50, 50)

        self.window = self.builder.get_object('MainWindow')
        self.window.set_icon(icon)
        self.liststore = self.builder.get_object('Liststore')
        ''' The liststore contains:
                0: a CFile instance which represent the file
                1: the file's path
                2: the file's name
                3: the file's mimetype
                4: the file's state (translated string)
                5: the cleaned copy's path
                6: the file's state (-1: unknown, 0: clean, 1: dirty)
        '''

        self.treeview = self.builder.get_object('Treeview')
        self.treeview.get_column(4).set_visible(self.backup)

        self.statusbar = self.builder.get_object('Statusbar')
        self.statusbar.push(1, _('Ready'))

        self.__init_supported_popup()
        self.__set_drag_treeview()

        self.window.show_all()

    def __init_supported_popup(self):
        ''' Initialize the "supported formats" popup '''
        self.supported_dict = mat.XMLParser()
        parser = xml.sax.make_parser()
        parser.setContentHandler(self.supported_dict)
        path = os.path.join(mat.get_datadir(), 'FORMATS')
        with open(path, 'r') as xmlfile:
            parser.parse(xmlfile)

        supported_cbox = self.builder.get_object('supported_cbox')
        store = Gtk.ListStore(int, str)
        for i, j in enumerate(self.supported_dict.list):
            store.append([i, j['name']])
        supported_cbox.set_model(store)
        supported_cbox.set_active(0)

        self.builder.get_object('supported_metadata').set_buffer(Gtk.TextBuffer())
        self.builder.get_object('supported_remaining').set_buffer(Gtk.TextBuffer())
        self.builder.get_object('supported_method').set_buffer(Gtk.TextBuffer())

        self.cb_update_supported_popup(supported_cbox)  # to initially fill the dialog

    def __set_drag_treeview(self):
        ''' Setup the drag'n'drop handling by the treeview '''
        self.treeview.drag_dest_set(Gtk.DestDefaults.MOTION |
            Gtk.DestDefaults.HIGHLIGHT | Gtk.DestDefaults.DROP,
            [], Gdk.DragAction.COPY)
        targets = Gtk.TargetList.new([])
        targets.add_uri_targets(80)
        self.treeview.drag_dest_set_target_list(targets)

    def cb_update_supported_popup(self, w):
        '''
            Fill GtkEntries of the supported_format_popups
            with corresponding data.
        '''
        i = w.get_active_iter()
        index, _ = w.get_model()[i]
        support = self.builder.get_object('supported_support')
        support.set_text(self.supported_dict.list[index]['support'])
        metadata = self.builder.get_object('supported_metadata').get_buffer()
        metadata.set_text(self.supported_dict.list[index]['metadata'])
        method = self.builder.get_object('supported_method').get_buffer()
        method.set_text(self.supported_dict.list[index]['method'])
        remaining = self.builder.get_object('supported_remaining').get_buffer()
        remaining.set_text(self.supported_dict.list[index]['remaining'])

    def cb_treeview_keyboard_event(self, widget, event):
        '''
            Remove selected files from the treeview
            when the use hit the 'suppr' key
        '''
        if Gdk.keyval_name(event.keyval) == "Delete":
            rows = []
            self.treeview.get_selection().selected_foreach(
                lambda model, path, iter: rows.append(iter))
            [self.liststore.remove(i) for i in rows]

    def cb_close_application(self, _):
        ''' Close the application '''
        Gtk.main_quit()

    def cb_add_files(self, button):
        ''' Add the files chosed by the filechoser ("Add" button) '''
        chooser = Gtk.FileChooserDialog(title=_('Choose files'),
            parent=self.window, action=Gtk.FileChooserAction.OPEN,
            buttons=(Gtk.STOCK_OK, 0, Gtk.STOCK_CANCEL, 1))
        chooser.set_default_response(0)
        chooser.set_select_multiple(True)

        all_filter = Gtk.FileFilter()  # filter that shows all files
        all_filter.set_name(_('All files'))
        all_filter.add_pattern('*')
        chooser.add_filter(all_filter)

        # filter that shows only supported formats
        supported_filter = Gtk.FileFilter()
        [supported_filter.add_mime_type(i) for i in strippers.STRIPPERS.keys()]
        supported_filter.set_name(_('Supported files'))
        chooser.add_filter(supported_filter)

        response = chooser.run()

        if not response:  # Gtk.STOCK_OK
            filenames = chooser.get_filenames()
            GObject.idle_add(self.populate(filenames).next)  # asynchrone processing
        chooser.destroy()

    def cb_popup_metadata(self, widget, row, col):
        '''
            Popup that display on double-clic
            metadata from a file

            FIXME: use a prettier GUI ?
        '''
        label = '<b>%s</b>\'s metadatas:\n' % self.liststore[row][1]
        meta = ''
        if not self.liststore[row][6] or self.liststore[row][0].file.is_clean():
            meta = 'No metadata found'
            self.liststore[row][4] = _('Clean')
        else:
            self.liststore[row][4] = _('Dirty')
            self.liststore[row][6] = 1
            iterator = self.liststore[row][0].file.get_meta().iteritems()
            for i, j in iterator:
                name = '-<b>' + str(i) + '</b> : '
                meta += (name + str(j) + '\n')

        w = Gtk.MessageDialog(self.window,
            Gtk.DialogFlags.MODAL | Gtk.DialogFlags.DESTROY_WITH_PARENT,
            Gtk.MessageType.INFO, Gtk.ButtonsType.CLOSE, label)
        w.set_resizable(True)
        w.set_size_request(400, 300)
        scrolled_window = Gtk.ScrolledWindow()
        scrolled_window.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)
        w.vbox.pack_start(scrolled_window, True, True, 0)
        content = Gtk.Label(label=meta)
        content.set_selectable(True)
        content.set_alignment(0, 0)
        content.set_use_markup(True)
        scrolled_window.add_with_viewport(content)
        w.set_markup(label)
        w.show_all()
        click = w.run()
        if click:
            w.destroy()

    def cb_about_popup(self, button):
        ''' About popup '''
        w = Gtk.AboutDialog()
        w.set_authors(['Julien (jvoisin) Voisin', ])
        w.set_artists(['Marine Benoît', ])
        w.set_copyright('GNU Public License v2')
        w.set_comments(_('This software was coded during the GSoC 2011'))
        w.set_logo(GdkPixbuf.Pixbuf.new_from_file_at_size(self.logo, 400, 200))
        w.set_program_name('Metadata Anonymisation Toolkit')
        w.set_version(mat.__version__)
        w.set_website('https://mat.boum.org')
        w.set_website_label(_('Website'))
        w.set_position(Gtk.WindowPosition.CENTER)
        w.run()
        w.destroy()

    def cb_supported_popup(self, w):
        ''' Show the "supported formats" popup'''
        dialog = self.builder.get_object('SupportedWindow')
        dialog.show_all()
        click = dialog.run()
        if not click:  # Close
            dialog.hide()

    def cb_clear_list(self, _):
        ''' Clear the file list '''
        self.liststore.clear()

    def cb_mat_check(self, button):
        ''' Callback for checking files '''
        self.__process_files(self.mat_check)

    def cb_mat_clean(self, button):
        ''' Callback for cleaning files '''
        self.__process_files(self.mat_clean)

    def cb_preferences_popup(self, button):
        ''' Preferences popup '''
        dialog = Gtk.Dialog(_('Preferences'), self.window, 0,
                (Gtk.STOCK_OK, 0))
        dialog.set_resizable(False)
        dialog.set_deletable(False)
        hbox = Gtk.HBox()
        dialog.get_content_area().pack_start(hbox, False, False, 0)

        icon = Gtk.Image()
        icon.set_from_stock(Gtk.STOCK_PREFERENCES, Gtk.IconSize.DIALOG)
        hbox.pack_start(icon, False, False, 20)

        table = Gtk.Table(3, 2, False)  # nb rows, nb lines
        hbox.pack_start(table, True, True, 0)

        force = Gtk.CheckButton(_('Force Clean'), False)
        force.set_active(self.force)
        force.connect('toggled', self.__invert, 'force')
        force.set_tooltip_text(_('Do not check if already clean before cleaning'))
        table.attach(force, 0, 1, 0, 1)

        backup = Gtk.CheckButton(_('Backup'), False)
        backup.set_active(self.backup)
        backup.connect('toggled', self.__invert, 'backup')
        backup.set_tooltip_text(_('Keep a backup copy'))
        table.attach(backup, 0, 1, 1, 2)

        pdf_quality = Gtk.CheckButton(_('Reduce PDF quality'), False)
        pdf_quality.set_active(self.pdf_quality)
        pdf_quality.connect('toggled', self.__invert, 'pdf_quality')
        pdf_quality.set_tooltip_text(_('Reduce the produced PDF size and quality'))
        table.attach(pdf_quality, 0, 1, 2, 3)

        add2archive = Gtk.CheckButton(_('Add unsupported file to archives'),
            False)
        add2archive.set_active(self.add2archive)
        add2archive.connect('toggled', self.__invert, 'add2archive')
        add2archive.set_tooltip_text(_('Add non-supported (and so \
non-anonymised) file to output archive'))
        table.attach(add2archive, 0, 1, 3, 4)

        hbox.show_all()
        if not dialog.run():  # Gtk.STOCK_OK
            for file in self.liststore:  # update preferences
                file[0].backup = self.backup
                file[0].add2archive = self.add2archive
                if file[2].startswith('pdf'):
                    file[0].pdf_quality = self.pdf_quality
            dialog.destroy()

    def cb_drag_data_received(self, widget, context,
            x, y, selection, target_type, timestamp):
        '''
            This function is called when something is
            drag'n'droped into mat.
            It basically add files.
        '''

        def clean_path(url):
            '''
                Since the dragged urls are ugly,
                we need to process them
            '''
            url = urllib2.unquote(url)  # unescape stupid chars
            url = url.decode('utf-8')  # decode in utf-8
            if url.startswith('file:\\\\\\'):  # windows
                return url[8:]  # 8 is len('file:///')
            elif url.startswith('file://'):  # nautilus, rox, thunar
                return url[7:]  # 7 is len('file://')
            elif url.startswith('file:'):  # xffm
                return url[5:]  # 5 is len('file:')

        urls = selection.get_uris()
        urls = map(clean_path, urls)
        GObject.idle_add(self.populate(urls).next)  # asynchrone processing

    def __add_file_to_treeview(self, filename):
        '''
            Add a file to the list if its format is supported
        '''
        cf = CFile(filename, self.backup, add2archive=self.add2archive,
                low_pdf_quality=self.pdf_quality)
        if cf.file:  # if the file is supported by the mat
            self.liststore.append([cf, os.path.dirname(cf.file.filename) + os.path.sep,
                cf.file.basename, cf.file.mime, _('unknow'), 'None', -1])
            return False
        return True

    def __process_files(self, func):
        '''
            Launch the function "func" in a asynchrone way
        '''
        iterator = self.treeview.get_selection().get_selected_rows()[1]
        if not iterator:  # if nothing is selected : select everything
            iterator = xrange(len(self.liststore))
        task = func(iterator)  # launch func() in an asynchrone way
        GObject.idle_add(task.next)

    def __invert(self, button, name):
        ''' Invert a preference state '''
        if name == 'force':
            self.force = not self.force
        elif name == 'pdf_quality':
            self.pdf_quality = not self.pdf_quality
        elif name == 'add2archive':
            self.add2archive = not self.add2archive
        elif name == 'backup':
            self.backup = not self.backup
            for line in xrange(len(self.liststore)):
                # change the "backup" property of all files
                self.liststore[line][0].file.backup = self.backup
            self.treeview.get_column(4).set_visible(self.backup)

    def populate(self, filenames):
        '''
            Append selected files by add_file to the self.liststore
        '''
        not_supported = []
        for filename in filenames:  # filenames : all selected files/folders
            if os.path.isdir(filename):  # if "filename" is a directory
                for root, dirs, files in os.walk(filename):
                    for item in files:
                        path_to_file = os.path.join(root, item)
                        if self.__add_file_to_treeview(path_to_file):
                            not_supported.append(item)
                        yield True
            else:  # filename is a regular file
                if self.__add_file_to_treeview(filename):
                    not_supported.append(filename)
                yield True
        if not_supported:
            self.__popup_non_supported(not_supported)
        yield False

    def __popup_non_supported(self, filelist):
        '''
            Popup that warn the user about the unsupported files
            that he want to process
        '''
        dialog = Gtk.Dialog(title=_('Not-supported'), parent=self.window,
                flags=0, buttons=(Gtk.STOCK_OK, 0))
        vbox = Gtk.VBox(spacing=5)
        dialog.get_content_area().pack_start(vbox, True, True, 0)
        store = Gtk.ListStore(str, str)

        # append filename - mimetype to the store
        for item in filelist:
            mime = mimetypes.guess_type(item)[0]
            if mime:
                store.append([item, mime])
            else:
                store.append([item, 'unknown'])

        treeview = Gtk.TreeView(store)
        vbox.pack_start(treeview, True, True, 0)

        #create column
        rendererText = Gtk.CellRendererText()
        column = Gtk.TreeViewColumn(_('Filename'), rendererText, text=0)
        treeview.append_column(column)
        column = Gtk.TreeViewColumn(_('Mimetype'), rendererText, text=1)
        treeview.append_column(column)

        dialog.show_all()
        click = dialog.run()
        if not click:  # Ok button
            dialog.destroy()

    def mat_check(self, iterator):
        ''' Check elements in iterator are clean '''
        for line in iterator:  # for each file in selection
            msg = _('Checking %s') % self.liststore[line][2].decode('utf-8', 'replace')
            logging.info(msg)
            self.statusbar.push(0, msg)

            if self.force or self.liststore[line][6]:
                if self.liststore[line][0].file.is_clean():
                    self.liststore[line][4] = _('Clean')
                    self.liststore[line][6] = 0
                else:
                    self.liststore[line][4] = _('Dirty')
                    self.liststore[line][6] = 1
                logging.info('%s is %s' % (self.liststore[line][1], self.liststore[line][4]))
                yield True
        self.statusbar.push(0, _('Ready'))
        yield False

    def mat_clean(self, iterator):
        ''' Clean elements in iterator '''
        for line in iterator:  # for each file in selection
            msg = _('Cleaning %s') % self.liststore[line][2].decode('utf-8', 'replace')
            logging.info(msg)
            self.statusbar.push(0, msg)
            if self.force or self.liststore[line][6]:
                if self.liststore[line][0].file.remove_all():
                    self.liststore[line][4] = _('Clean')
                    self.liststore[line][6] = 0
                    if self.backup:  # the backup copy state
                        self.liststore[line][5] = os.path.basename(self.liststore[line][0].file.output)
            yield True
        self.statusbar.push(0, _('Ready'))
        yield False

if __name__ == '__main__':
    gettext.install('MAT', unicode=True)

    gui = GUI()

    #Add files from command line
    infiles = [arg for arg in sys.argv[1:] if os.path.exists(arg)]
    if infiles:
        task = gui.populate(infiles)
        GObject.idle_add(task.next)

    Gtk.main()
